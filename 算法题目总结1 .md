<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

##### 1. 求原根个数 [数论] [普及+/提高]

[CF284A Cows and Primitive Roots](https://www.luogu.com.cn/problem/CF284A)

题目描述：

奶牛们刚学会原根的定义! 给定一个质数 $p$ 那么模 $p$ 意义下的一个原根  $x (1<=x<p)$ 满足如下性质: 

$x-1, x^2-1, x^3-1 \cdots  x^{p-2}-1$都不能被 $p$ 整除,但是$x^{p-1}-1$却可以。

但是奶牛们太菜了需要你的帮助,给定一个质数 _**p**_,求模 _**p**_ 意义下原根的个数。



关键点：

1. $x^i -1$ 不能被p整除   $\iff$  $x^i$ 模p不能等于 **1**,  $x^i -1$ 能被p整除   $\iff$ $x^i$ 模 $p$ 等于 **1**,  所以只需要判断 $x^i$ 模 $p$的情况。

2. 模运算的规则：
   $$
   (a + b)~~\%~~p = (a~~\%~~p~~+~~b~~\%~~p)~~\%~~p
   $$
   
   $$
   (a - b)~~\%~~p = (a~~\%~~p~~-~~b~~\%~~p)~~\%~~p
   $$
   
   $$
   (a~*b)~~\%~~p = (a~~\%~~p~~*~~b~~\%~~p)~~\%~~p
   $$

3. 

​    
$$
~~~~~~(~a^b~)~~\%~~p ~~=~~ (~~(a~\%~p)^b~~)~~\%~~p
$$
​	    应用公式(3):
$$
x^i~~\%~~p ~~=~~ (x^{i-1}~~\%~~p~~*~~x~~\%~~p)~~\%~~p
$$
 部分代码：

```cpp
bool solve(int x)
{
    int res = 1;
    int temp = x % p;
    for (int i = 1; i < p - 1; ++i)
    {
        res = (res * temp) % p;
        if (res == 1)
            return false;
    }
    res = (res * temp) % p;
    if (res == 1)
        return true;
    return false;
}
```



#####  2. 过河卒 [动态规划] [普及-]

[P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)

题目描述：

棋盘上 A*A* 点有一个过河卒，需要走到目标 B*B* 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C*C* 点有一个对方的马，该马  		所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，A*A* 点 (0, 0)(0,0)、B*B* 点 (n, m)(*n*,*m*)，同样马的位置坐标是需要给出的。

现在要求你计算出卒从 A*A* 点能够到达 B*B* 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。



关键点：

 1. 用一个set，将马通过0步或一步能到的位置提前存储起来。

 2. 状态转移方程为：
    $$
    f[1][1]=1
    $$
    
    $$
    f[i][j] = \max( f[i-1][j] + f[i][j-1] , f[i][j] )
    $$

关键代码：

```cpp
        for (int j = 1; j <= m; ++j)
        {
            if (s.count(pair<int, int>(i, j)) == 1)
            {
                dp[i][j] = 0;
                continue;
            }
            if (i == 0)
                dp[i][j] = dp[i][j-1];
            else
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
```

##### 3. 铺地毯 [模拟] [普及-]

[P1003 [NOIP2011 提高组] 铺地毯](https://www.luogu.com.cn/problem/P1003)

题目：

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n*n* 张地毯，编号从 11 到 n*n*。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。

输入共 *n*+2 行。

第一行，一个整数 *n*，表示总共有 *n* 张地毯。

接下来的 *n* 行中，第 *i*+1 行表示编号 *i* 的地毯的信息，包含四个整数 *a*, *b*, *g*, *k*，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 (*a*,*b*) 以及地毯在 *x* 轴和 *y* 轴方向的长度。

第 *n*+2 行包含两个整数 *x* 和 *y*，表示所求的地面的点的坐标 (*x*,*y*)。



关键点：

1. 巧妙利用输入的先后关系来处理地毯的上下关系。

   

```cpp
int res=-1,n, x, y;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d%d%d%d", &arr[i].a, &arr[i].b, &arr[i].g, &arr[i].k);
    }
    scanf("%d%d", &x, &y);
    for(int i=1;i<=n;++i){
        if(x>=arr[i].a&&x<=arr[i].a+arr[i].g&&y>=arr[i].b&&y<=arr[i].b+arr[i].k)
            res=i;
    }
    printf("%d\n",res);
```



##### 4. 三连击[枚举/暴力] [普及-]

[P1008 [NOIP1998 普及组] 三连击](https://www.luogu.com.cn/problem/P1008)

题目描述：

$将 1, 2, \ldots , 9共 9 个数分成 3 组，分别组成 3 个三位数，且使这 3 个三位数构成 1:2:3 的比例，试求出所有满足条件的 3 个三位数。$



看代码：

```cpp
int a,b,c;
for(a=123;a<=333;a++)
{
 	b=a*2;
	c=a*3;
    if((a/100+a/10%10+a%10+b/100+b/10%10+b%10+c/100+c/10%10+c%10==1+2+3+4+5+6+7+8+9)&&((a/100)*(a/10%10)*(a%10)*(b/100)*(b/10%10)*(b%10)*(c/100)*(c/10%10)*(c%10)==(1)*(2)*(3)*(4)*(5)*(6)*(7)*(8)*(9)))
    	printf("%d %d %d\n",a,b,c);
}
```



```cpp
 for(i=192;i<=327;i++)//第一个数最小192，最大327。其实不知道的情况下简单来说是从123-329的但是算出来是最值就稍微改了下下
    {
        memset(a,0,sizeof(a));v=0;//清零
        a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;//统计数字
        for(j=1;j<=9;j++) v+=a[j];//v表示1-9这些数字是否全部齐了
        if(v==9) printf("%d %d %d\n",i,i*2,i*3);//如果齐了就输出
    }
```



##### 5. Cantor 表 [模拟/枚举/暴力] [入门]

[P1014 [NOIP1999 普及组] Cantor 表](https://www.luogu.com.cn/problem/P1014)



题目描述：

现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：

1/1 , 1/2 , 1/3 , 1/4, 1/5, …

2/1,  2/2 , 2/3, 2/4, …

3/1 , 3/2,  3/3, …

4/1,  4/2, …

5/1, …

…

我们以 Z 字形给上表的每一项编号。第一项是 1/1，然后是 1/2，2/1，3/1，2/2，…



关键点：



算法1：模拟，按题意一个个枚举

时间复杂度O(n),可以通过本题n≤10^7



算法2：发现Z字形的每条斜线可以快速枚举，即枚举

1/1 , 1/2 , 3/1 , 1/4 , 5/1 , 1/6……找到要求的第n项所在斜线，再一个个枚举或计算得出答案

时间复杂度O(√n),可以通过n≤10^14



算法3：发现第i条斜线（即分子分母之和=i+1的所有项）中包含i*(i-1)/2+1至i*(i+1)中的每一项，所以可以二分分子分母之和，再根据分	   子分母之和的奇偶性直接计算第n项

时间复杂度O(㏒₂n),可以通过n≤10^18,加上高精可通过n≤10^1000



算法2代码：

```cpp
    for (int i = 1; i <= 10000; ++i)
    {
        a[i] = i * (i - 1) / 2 + 1;
    }
    int k = lower_bound(a + 1, a + 10001, n) - a;
    if (a[k] != n)
        --k;
    if (k & 1)
    {
        cout << k - (n - a[k]) << "/" << 1 + n - a[k] << endl;
    }
    else
    {
        cout << 1 + n - a[k] << "/" << k - (n - a[k]) << endl;
    }
```



算法3代码：

```cpp
 long long l=1,r,mid,n,a;
        cin>>n;
        r=n;
        while(l<r){
            mid=(l+r)/2;
            if(mid*(mid+1)/2<n)l=mid+1;
            else r=mid;
        }
        a=n-l*(l-1)/2;
        if(l%2==0)cout<<a<<'/'<<l+1-a;
        else cout<<l+1-a<<'/'<<a;
```



##### 6. 单词接龙 [字符串/搜索] [普及+/提高-]

[P1019 [NOIP2000 提高组] 单词接龙](https://www.luogu.com.cn/problem/P1019)



题目描述：

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。



代码：

```cpp
int n, g[21][21], ans, c[21], len[21], b[42];
string a[21];
char s;
void dfs(int x, int cnt) 
{
    bool f = false;
    for (int i = 1; i <= n; ++i)
    {
        if (g[x][i] && c[i] < 2)
        {
            f = true;
            ++c[i];
            b[cnt + 1] = i;
            dfs(i, cnt + 1);
            b[cnt + 1] = 0;
            --c[i];
        }
    }
    if (!f)
    {
        int count = 0;
        for (int i = 0; i <= cnt; ++i)
        {
            count += len[b[i]];
        }
        for (int i = 0; i < cnt; ++i)
        {
            count -= g[b[i]][b[i + 1]];
        }
        if (count > ans)
            ans = count;
    }
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i];
        len[i] = a[i].size();
    }
    cin >> s;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            string s1 = a[i], s2 = a[j];
            int k = 0;
            if (i == j)
                k = 1;
            for (; k < s1.size(); ++k)
            {
                if (s1[k] == s2[0])
                {
                    int v = k;
                    while (v < s1.size() && v - k < s2.size())
                    {
                        if (s1[v] != s2[v - k])
                            break;
                        ++v;
                    }
                    if (v == s1.size())
                    {
                        if (k == 0 || v - k == s2.size())
                            break;
                        else
                            g[i][j] = s1.size() - k;
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        if (a[i][0] == s)
        {
            c[i] = 1;
            b[0] = i;
            dfs(i, 0);
        }
    }
    printf("%d\n", ans); 
    system("pause");
    return 0;
}
```





关键点：

1. 用矩阵g\[i]][j]记录字符串 $i$ 和 $j$ 首尾相连时重合部分的长度。数组a记录字符串的输入顺序。数组b\[i]记录第 $i$ 次选的是第几个字符串。数组c[i]记录第 $i$ 个字符串被选了几次。

2.  看清楚题目，求的是长度，而不是字符串。

3. 注意单词有可能自己和自己连接，

4. 注意数组作为参数传递的情况，

5. 回溯不需要传递数组，直接用全局数组就可以。

6. 注意长度不要重复加。

7. dfs前，注意一些变量的赋值。

8. 写代码之前想清楚怎么写。

9. 不要写错了变量。

10. 明确各个变量的意义。

    

##### 7. 数的计算 [递推/递归] [普及-]

[P1028 [NOIP2001 普及组] 数的计算1](https://www.luogu.com.cn/problem/P1028)



题目描述：

我们要求找出具有下列性质数的个数(包含输入的正整数 *n*)。

先输入一个正整数 *n*(*n*≤1000),然后对此正整数按照如下方法进行处理：

1. 不作任何处理；
2. 在它的左边加上一个正整数,但该正整数不能超过原数的一半；
3. 加上数后,继续按此规则进行处理,直到不能再加正整数为止。



方法1：暴力递归：

```cpp
#include<cstdio>
using namespace std;
int n,cnt=1;
void func(int x){
    for(int i=1;i<=x/2;i++){
        cnt++;
        func(i);
    }
}
int main(){
    scanf("%d",&n);
    func(n);
    printf("%d\n",cnt);
}
```

这个递归大概能骗过n=500，然而题目中是n<=1000 所以正解肯定不是暴力。



方法2：递推

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n;
int f[1001];//存每一位数的种类
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){ //1-n的递推
        for(int j=1;j<=i/2;j++){
            f[i]+=f[j]; //每一位叠加，递推走起
        }
        f[i]++; //加上本身
    }
    cout<<f[n];//输出n的种类
    return 0;
}
```

我们以4为例子来进行说明

4后面可以跟上1,2组成14,24

14后面跟不了,24可以跟上1组成124

再加上4本身就可以得到4的种类

即 14,24,124,4

而我们只要算出1,2的种类就可以加起来得到4的种类

总体来说，这道题是数学思想以及对递推的理解。



##### 8. 求先序排列 [字符串/树形结构/递归] [普及-]

[P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030)



题目描述：

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度≤8）。



关键点：



首先，一点基本常识，给你一个后序遍历，那么最后一个就是根（如ABCD，则根为D）。

因为题目求先序，意味着要不断找根。

那么我们来看这道题方法：（示例）

中序ACGDBHZKX，后序CDGAHXKZB，首先可找到主根B；

那么我们找到中序遍历中的B，由这种遍历的性质，可将中序遍历分为ACGD和HZKX两棵子树，

那么对应可找到后序遍历CDGA和HXKZ（从头找即可）

从而问题就变成求1.中序遍历ACGD，后序遍历CDGA的树 2.中序遍历HZKX，后序遍历HXKZ的树；

接着递归，按照原先方法，找到1.子根A，再分为两棵子树2.子根Z，再分为两棵子树。

就按这样一直做下去（先输出根，再递归）；

模板概括为step1:找到根并输出

step2:将中序，后序各分为左右两棵子树；

step3:递归，重复step1,2；



代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
void beford(string in,string after){
    if (in.size()>0){
        char ch=after[after.size()-1];
        cout<<ch;//找根输出
        int k=in.find(ch);
        beford(in.substr(0,k),after.substr(0,k));
        beford(in.substr(k+1),after.substr(k,in.size()-k-1));//递归左右子树；
    }
}
int main(){
    string inord,aftord;
    cin>>inord;cin>>aftord;//读入
    beford(inord,aftord);cout<<endl;
    return 0;
}
```



##### 9. 选数 [DFS] [普及-]

[P1036 [NOIP2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)



题目描述：

已知 *n* 个整数 x*1,*x*2,…,*x**n*，以及11个整数*k*(*k*<*n*)。从*n*个整数中任选*k*个整数相加，可分别得到一系列的和。例如当*n*=4,*k*=3,44个整数分别为3,7,12,19时，可得全部的组合与它们的和为：

3+7+12=22

3+7+19=29

7+12+19=38

3+12+19=34。

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：3+7+19=29



代码：

```cpp
#include<iostream>
#include<math.h>
using namespace std;
int x[20],n,k;//依照题目所设
bool isprime(int n){//判断是否质数
    int s=sqrt(double(n));
    for(int i=2;i<=s;i++){
        if(n%i==0)return false;
    }
    return true;
}
int rule(int choose_left_num,int already_sum,int start,int end){//choose_left_num为剩余的k，already_sum为前面累加的和，start和end为全组合剩下数字的选取范围；调用递归生成全组合，在过程中逐渐把K个数相加，当选取的数个数为0时，直接返回前面的累加和是否为质数即可
    if(choose_left_num==0)return isprime(already_sum);
    int sum=0;
    for(int i=start;i<=end;i++){
        sum+=rule(choose_left_num-1,already_sum+x[i],i+1,end);
    }
    return sum;
}
int main(){
    cin>>n>>k;
    for(int i =0;i<n;i++)cin>>x[i];
    cout<<rule(k,0,0,n-1);//调用递归解决问题
}
```

其实这里的难点是：如何去重？

答案是：不降原则



##### 10. 乒乓球 [字符串/模拟] [普及-]

[P1042 [NOIP2003 普及组] 乒乓球](https://www.luogu.com.cn/problem/P1042)



题目描述：

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在1111分制和2121分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中`W`表示华华获得一分，`L`表示华华对手获得一分）：

WWWWWWWWWWWWWWWWWWWWWWLW

在1111分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。直到分差大于或者等于2，才一局结束。

你的程序就是要对于一系列比赛信息的输入（*W**L*形式），输出正确的结果。



关键点：

1. 比赛必须要有一方的分数不小于11或21, 并且领先2个球才能获胜，11:10的比分是不存在的

   

代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
char a[62510];
int cnt = 0, x = 0, y = 0;
int main()
{
    while (scanf(" %c", &a[++cnt]))
    {
        if (a[cnt] == 'E')
            break;
    }
    for (int i = 1; i < cnt; ++i)
    {
        if (a[i] == 'W')
            ++x;
        else if (a[i] == 'L')
            ++y;
        if ((x >= 11 && x - 2 >= y) || (y >= 11 && y - 2 >= x))
        {
            printf("%d:%d\n", x, y);
            x = y = 0;
        }
    }
    printf("%d:%d\n", x, y); //最后要输出，即使是x=y=0，不要忘记了。
    printf("\n");
    x = y = 0;
    for (int i = 1; i < cnt; ++i)
    {
        if (a[i] == 'W')
            ++x;
        else
            ++y;
        if ((x >= 21 && x - 2 >= y) || (y >= 21 && y - 2 >= x))
        {
            printf("%d:%d\n", x, y);
            x = y = 0;
        }
    }
    printf("%d:%d\n", x, y); //最后要输出，即使是x=y=0，不要忘记了。
    return 0;
}
```



##### 11. 栈 [dp, catalan,递推] [普及-]

[P1044 [NOIP2003 普及组] 栈](https://www.luogu.com.cn/problem/P1044)



题目描述：

一个操作数序列 1,2,…,*n*，栈 A 的深度大于 *n*。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）

2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

   

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列。

你的程序将对给定的 n*n*，计算并输出由操作数序列 1,2,\ldots,n1,2,…,*n* 经过操作可能得到的输出序列的总数。



1. 递归/记忆化搜索

   看这个数据，我总感觉dfs会超时，然后真的超了？（没试过），于是很自然的，我们就会想到记忆化搜索，这也是做这题的一种技巧吧，但无论如何，这也是最基础的

​      下面谈谈搜索(递归)思路：

- 既然记忆化搜索了，定义一个二维数组*f*[*i*,*j*]，用下标 *i* 表示队列里还有几个待排的数，*j* 表示栈里有 *j* 个数，*f*[*i*,*j*]表示此时的情况数

- 那么，更加自然的，只要f[i,j]*f*[*i*,*j*]有值就直接返回；

- 然后递归如何实现呢？首先，可以想到，要是数全在栈里了，就只剩1种情况了，所以：i*=0时，返回1；

- 然后，有两种情况：一种栈空，一种栈不空：在栈空时，我们不可以弹出栈里的元素，只能进入，所以队列里的数−1，栈里的数+1，即加上 *f*[*i*−1,*j*+1] ；另一种是栈不空，那么此时有出栈1个或者进1个再出1个 2种情况，分别加上 *f*[*i*−1,*j*+1] 和 *f*[*i*,*j*−1] ，便是此时的情况了，于是递归就愉快的结束了；

  

2. 动态规划

   c\[i][j]表示有i个数已经进栈，有j个数已经出栈的方法总数

   那么如果现在有i-1个数进栈，j个数出栈，不难发现，再入栈一个数就能得到i个数进栈，j个数出栈的状况

   如果有i个数进栈，j-1个数出栈，不难发现，再出栈一个数就能得到i个数进栈，j个数出栈的状况。
   $$
   c[i][j]=c[i−1][j]+c[i][j−1]
   $$
   i个数进栈，0个数出栈不是只有1种方法。

   

3. catalan

   递推式1
   $$
   f[n]=f[0]*f[n-1] + f[1]*f[n-2] + ... + f[n-1]f[0] (n≥2)
   $$
   递推式2
   $$
   f[n]=C[2n,n]−C[2n,n−1](n=0,1,2,...) 
   $$
   

   代码：

   ```cpp
   ll c[MAX_N*2][MAX_N];
   int main(){
   
       scanf("%d",&n);
       for(int i=1;i<=2*n;i++)
       {
       	c[i][0]=c[i][i]=1;
       	for(int j=1;j<i;j++)
       	{
       		c[i][j]=c[i-1][j]+c[i-1][j-1];
   		}
   	}
       printf("%lld",c[2*n][n]-c[2*n][n-1]);
       return 0;
   }
   ```



##### 12. 麦森数 [数论/高精] [普及/提高-]

[P1045 [NOIP2003 普及组] 麦森数](https://www.luogu.com.cn/problem/P1045)

形如 $2^P−1$  的素数称为麦森数，这时*P*一定也是个素数。但反过来不一定，即如果*P*是个素数，$2^P−1$不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是P*=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。

任务：从文件中输入*P*（1000<*P*<3100000），计算 $2^P−1$ 的位数和最后500位数字（用十进制高精度数表示）

第一行：十进制高精度数$2^P−1$  的位数。

第2-11行：十进制高精度数$2^P−1$  的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0）



这道题可以分为两个模块，第一个模块为求的位数，第二个模块为求的后500位（不足补零）。我们主要来解决第一个模块：

一、求位数

首先我们知道 $2^{p}-1$ 与 $2^p$ 有着相同的位数，因为2的次方满足了最后一位不为零的要求，所以减一后位数并不会改变，那么我们可以直接求  $2^p$ 的位数。那么怎么求位数呢？我们不妨设 $k=2^p$，根据 $10^n$ 的位数为 $n+1$，我们只要想办法把  中的底数$k=2^p$改为10，指数加一就是位数了。由此想到用10的几次方来代替2，那么就不难想到 $10^{log_{10}2}=2$ ，这样便可以把  中的2代换掉， $k=2^p$ 变为了 $k=(10^{log_{10}2})^p$ 。根据乘方的原理，将p乘进去，原式便可化为我们最终想要的形式 $k=10^{p*log_{10}2}$  了，所以位数就是$10^{p*log_{10}2}+1$ 。

二、求最后500位数

高精快速幂



##### 13. 装箱问题 [dp,背包] [普及-]

[P1049 [NOIP2001 普及组] 装箱问题](https://www.luogu.com.cn/problem/P1049)



题目描述

有一个箱子容量为*V*（正整数, 0≤*V*≤20000），同时有*n*个物品（0<*n*≤30，每个物品有一个体积（正整数）。

要求*n*个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。



关键点：

将价值设置为体积的大小，运用01背包问题即可解决。



##### 14. 金明的预算方案 [dp] [普及+/提高]

[P1064 [NOIP2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)



题目描述：

​	  金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他··		说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 *n* 元钱就行”。今天一早，金明就开始做预算了，他把想买的		物品分为两类：主件与附件，附件是从属于某个主件的，



​      如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、1 个或 2 个附件。每个附件对应一个主件，附		件 不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 *n* 元。于是，他把每件物品规定了一个重要度，分为 5 		等：用整数 1∼5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 *n* 元的前		提下，使每件物品的价格与重要度的乘积的总和最大。

设第 j*j* 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 *k* 件物品，编号依次为$j_1,j_2,\dots,j_k$则所求的总和为：
$$
v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}
$$
请你帮助金明设计一个满足要求的购物单。



第一行有两个整数，分别表示总钱数 n*n* 和希望购买的物品个数 m*m*。

第 22 到第(*m*+1) 行，每行三个整数，第 (*i*+1) 行的整数 $v_i，p_i，q_i$ 分别表示第 *i* 件物品的价格、重要度以及它对应的的主件。如果      		$q_i=0$，表示该物品本身是主件。



思路：

还记得01背包的决策是什么吗？

1.不选，然后去考虑下一个

2.选，背包容量减掉那个重量，总值加上那个价值。

这个题的决策是五个，分别是：

1.不选，然后去考虑下一个

2.选且只选这个主件

3.选这个主件，并且选附件1

4.选这个主件，并且选附件2

5.选这个主件，并且选附件1和附件2.