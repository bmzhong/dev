<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

##### 1. 求原根个数 [数论] [普及+/提高]

[CF284A Cows and Primitive Roots](https://www.luogu.com.cn/problem/CF284A)

题目描述：

奶牛们刚学会原根的定义! 给定一个质数 $p$ 那么模 $p$ 意义下的一个原根  $x (1<=x<p)$ 满足如下性质: 

$x-1, x^2-1, x^3-1 \cdots  x^{p-2}-1$都不能被 $p$ 整除,但是$x^{p-1}-1$却可以。

但是奶牛们太菜了需要你的帮助,给定一个质数 _**p**_,求模 _**p**_ 意义下原根的个数。



关键点：

1. $x^i -1$ 不能被p整除   $\iff$  $x^i$ 模p不能等于 **1**,  $x^i -1$ 能被p整除   $\iff$ $x^i$ 模 $p$ 等于 **1**,  所以只需要判断 $x^i$ 模 $p$的情况。

2. 模运算的规则：
   $$
   (a + b)~~\%~~p = (a~~\%~~p~~+~~b~~\%~~p)~~\%~~p
   $$
   
   $$
   (a - b)~~\%~~p = (a~~\%~~p~~-~~b~~\%~~p)~~\%~~p
   $$
   
   $$
   (a~*b)~~\%~~p = (a~~\%~~p~~*~~b~~\%~~p)~~\%~~p
   $$

3. 

​    
$$
~~~~~~(~a^b~)~~\%~~p ~~=~~ (~~(a~\%~p)^b~~)~~\%~~p
$$
​	    应用公式(3):
$$
x^i~~\%~~p ~~=~~ (x^{i-1}~~\%~~p~~*~~x~~\%~~p)~~\%~~p
$$
 部分代码：

```cpp
bool solve(int x)
{
    int res = 1;
    int temp = x % p;
    for (int i = 1; i < p - 1; ++i)
    {
        res = (res * temp) % p;
        if (res == 1)
            return false;
    }
    res = (res * temp) % p;
    if (res == 1)
        return true;
    return false;
}
```



#####  2. 过河卒 [动态规划] [普及-]

[P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)

题目描述：

棋盘上 A*A* 点有一个过河卒，需要走到目标 B*B* 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C*C* 点有一个对方的马，该马  		所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，A*A* 点 (0, 0)(0,0)、B*B* 点 (n, m)(*n*,*m*)，同样马的位置坐标是需要给出的。

现在要求你计算出卒从 A*A* 点能够到达 B*B* 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。



关键点：

 1. 用一个set，将马通过0步或一步能到的位置提前存储起来。

 2. 状态转移方程为：
    $$
    f[1][1]=1
    $$
    
    $$
    f[i][j] = \max( f[i-1][j] + f[i][j-1] , f[i][j] )
    $$

关键代码：

```cpp
        for (int j = 1; j <= m; ++j)
        {
            if (s.count(pair<int, int>(i, j)) == 1)
            {
                dp[i][j] = 0;
                continue;
            }
            if (i == 0)
                dp[i][j] = dp[i][j-1];
            else
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
```

##### 3. 铺地毯 [模拟] [普及-]

[P1003 [NOIP2011 提高组] 铺地毯](https://www.luogu.com.cn/problem/P1003)

题目：

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 n*n* 张地毯，编号从 11 到 n*n*。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。

输入共 *n*+2 行。

第一行，一个整数 *n*，表示总共有 *n* 张地毯。

接下来的 *n* 行中，第 *i*+1 行表示编号 *i* 的地毯的信息，包含四个整数 *a*, *b*, *g*, *k*，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 (*a*,*b*) 以及地毯在 *x* 轴和 *y* 轴方向的长度。

第 *n*+2 行包含两个整数 *x* 和 *y*，表示所求的地面的点的坐标 (*x*,*y*)。



关键点：

1. 巧妙利用输入的先后关系来处理地毯的上下关系。

   

```cpp
int res=-1,n, x, y;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d%d%d%d", &arr[i].a, &arr[i].b, &arr[i].g, &arr[i].k);
    }
    scanf("%d%d", &x, &y);
    for(int i=1;i<=n;++i){
        if(x>=arr[i].a&&x<=arr[i].a+arr[i].g&&y>=arr[i].b&&y<=arr[i].b+arr[i].k)
            res=i;
    }
    printf("%d\n",res);
```



##### 4. 三连击[枚举/暴力] [普及-]

[P1008 [NOIP1998 普及组] 三连击](https://www.luogu.com.cn/problem/P1008)

题目描述：

$将 1, 2, \ldots , 9共 9 个数分成 3 组，分别组成 3 个三位数，且使这 3 个三位数构成 1:2:3 的比例，试求出所有满足条件的 3 个三位数。$



看代码：

```cpp
int a,b,c;
for(a=123;a<=333;a++)
{
 	b=a*2;
	c=a*3;
    if((a/100+a/10%10+a%10+b/100+b/10%10+b%10+c/100+c/10%10+c%10==1+2+3+4+5+6+7+8+9)&&((a/100)*(a/10%10)*(a%10)*(b/100)*(b/10%10)*(b%10)*(c/100)*(c/10%10)*(c%10)==(1)*(2)*(3)*(4)*(5)*(6)*(7)*(8)*(9)))
    	printf("%d %d %d\n",a,b,c);
}
```



```cpp
 for(i=192;i<=327;i++)//第一个数最小192，最大327。其实不知道的情况下简单来说是从123-329的但是算出来是最值就稍微改了下下
    {
        memset(a,0,sizeof(a));v=0;//清零
        a[i%10]=a[i/10%10]=a[i/100]=a[i*2%10]=a[i*2/10%10]=a[i*2/100]=a[i*3%10]=a[i*3/10%10]=a[i*3/100]=1;//统计数字
        for(j=1;j<=9;j++) v+=a[j];//v表示1-9这些数字是否全部齐了
        if(v==9) printf("%d %d %d\n",i,i*2,i*3);//如果齐了就输出
    }
```



##### 5. Cantor 表 [模拟/枚举/暴力] [入门]

[P1014 [NOIP1999 普及组] Cantor 表](https://www.luogu.com.cn/problem/P1014)



题目描述：

现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：

1/1 , 1/2 , 1/3 , 1/4, 1/5, …

2/1,  2/2 , 2/3, 2/4, …

3/1 , 3/2,  3/3, …

4/1,  4/2, …

5/1, …

…

我们以 Z 字形给上表的每一项编号。第一项是 1/1，然后是 1/2，2/1，3/1，2/2，…



关键点：



算法1：模拟，按题意一个个枚举

时间复杂度O(n),可以通过本题n≤10^7



算法2：发现Z字形的每条斜线可以快速枚举，即枚举

1/1 , 1/2 , 3/1 , 1/4 , 5/1 , 1/6……找到要求的第n项所在斜线，再一个个枚举或计算得出答案

时间复杂度O(√n),可以通过n≤10^14



算法3：发现第i条斜线（即分子分母之和=i+1的所有项）中包含i*(i-1)/2+1至i*(i+1)中的每一项，所以可以二分分子分母之和，再根据分	   子分母之和的奇偶性直接计算第n项

时间复杂度O(㏒₂n),可以通过n≤10^18,加上高精可通过n≤10^1000



算法2代码：

```cpp
    for (int i = 1; i <= 10000; ++i)
    {
        a[i] = i * (i - 1) / 2 + 1;
    }
    int k = lower_bound(a + 1, a + 10001, n) - a;
    if (a[k] != n)
        --k;
    if (k & 1)
    {
        cout << k - (n - a[k]) << "/" << 1 + n - a[k] << endl;
    }
    else
    {
        cout << 1 + n - a[k] << "/" << k - (n - a[k]) << endl;
    }
```



算法3代码：

```cpp
 long long l=1,r,mid,n,a;
        cin>>n;
        r=n;
        while(l<r){
            mid=(l+r)/2;
            if(mid*(mid+1)/2<n)l=mid+1;
            else r=mid;
        }
        a=n-l*(l-1)/2;
        if(l%2==0)cout<<a<<'/'<<l+1-a;
        else cout<<l+1-a<<'/'<<a;
```



